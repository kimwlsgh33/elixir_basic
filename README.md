# elixir

## excute

```sh 
elixir hello.exs
# => HelloWorld!

iex
c "hello.exs"
# => HelloWorld!
# => [moduleName]
```

### c hellper function
- 독립적인 코드로 컴파일 

### import file
- 파일의 각 줄을, iex에 입력한 것 처럼 사용할 수 있다.

## 무엇을 언제 질문해야하는지 아는 것을 목표로 함
- 코드 작성
- 궁금한 것 탐색

### 엘릭서를 배우면서 알게될것들
- 조건문이 기본이 아닐 수 있다.
- 동시성에 락, 세마포어, 모니터가 필요하지 않을 수 있다.
- 프로세스가 비싼 자원이 아닐 수 있다.
- 메타프로그래밍은, 언어와 별개이다.
- 프로그래밍은 재밌어야 한다.


# 패턴 매칭

## 엘릭서에서 "=" 는, 단언문이다.
- 왼쪽과 오른쪽이 같다면, 실행에 성공한다. 
- 매치 연산자라고 부른다. (대입 연산자 아님!!)

``` elixir
a = 1 (변수가 왼쪽에 있을때는 바인딩한다.)
1 = a (매칭 성공)
2 = a (매칭 실패)


list = [1,2,3] (바인딩)
[a,b,c] = list (패턴 매칭)
a (1)
b (2)
c (3)
```

### 패턴 매칭이란? - 좌변과 우변을 같게 만들거나, 비교한다!
- 값이 있으면, 값을 바인딩
- 변수가 있으면, 변수 우변에 있는 값을 바인딩

- 구조가 같아야 함
- 리터럴이 있으면, 값이 일치해야 함 (리터럴 : "name":"jinho" 에서 "name"을 뜻함)

( 같게 만들 수 있으면 값을 반환하고, 같게 만들 수 없으면 에러를 반환한다 )

#### 할당과 바인딩의 차이점
- 할당 : 메모리 확보
- 바인딩 : 값과 변수를 연결 (이미 존재하는 것을 연결만 해줌)

### 사용하지 않는 값, 매칭 후에 버리기
- (_) 언더스코어를 사용한다.

``` elixir
list = [1,2,3]
[a,b,_] = list
```

### 하나의 매칭에서, 똑같은 변수를 사용한다면?

``` elixir
[a,a] = [1,1] # 매칭 성공, 동시에 같은 값을 바인딩 (다른 프로세스)

[b,b] = [1,2] # 매칭 실패, 2바인딩을 동시에 진행하는데 값이 다르므로 실패
```

### 바인딩하지 않고, 비교만하는 방법

``` elixir
^a = 1 # a와 1을 비교한다. ( 바인딩하지 않는다. 1=a 와 같음)
```


엘릭서는 변수에 값을 여러차례 결정 가능
얼랭은 한번만 결정 가능

수학의 수식과 동일하게 사용한다.
- 비교의 용도이지, 대입의 용도가 아니다!
- 우리는 수식에서 양변이 같은지를 확인하지, 왼쪽에 오른쪽을 집어넣지 않는다.

# 불변성

- 한번 생성한 데이터를 변경할 수 없다는 점

## 왜 중요한가?

- 많은 프로그래밍에서 포인터(레퍼런스)를 사용하는데, 이 때문에 해당 값의 불변성을 확신할 수 없다.
  - 다중 스레드 환경에서 모든 스레드가 해당 주소의 값을 변경한다면?

- 가변성은, 어떻게 이런 상태가 되었지? 라는 의문점이 생긴다. ( 이는 불필요하다 )


## Elixir는 모든 값이 불변이다.
- [1,2,3] 같은 리스트를 한번 참조하면, 다시 바인딩하지 않는 한 항상 같은 값을 참조한다.
  - 동시성 처리를 두려워할 일이 크게 줄어든다.
  
- [1,2,3]의 각요소에 100을 더해야 한다면?
  - 복사본을 만든뒤, 복사본에 새로운 값을 담는다. (원본에 영향x)
  
## 항상 복사본을 만드는 것이, 비효율적이지 않고 오히려 효율적인 이유
- 새로운 자료구조를 만들때, 이전에 존재하는 데이터의 일부 or 전부를 재사용할 수 있다!

``` elixir
[head|tail] # head와 tail을 합쳐서 [head, tail] 이라는 리스트 1개를 "새롭게 만든다"
```

## 가비지 컬렉션
- 이전 값에서 새 값을 만듬 => 사용하지 않는 오래된 값들을 남겨두는 경우가 많다
- heap 메모리에 남아있는 오래된 것들을 가비지 컬렉터가 이를 정리해주어야 한다
  - 하나의 heap 영역에서 값들을 찾아야 하므로, 성능에 부정적일 수 있음
  
- 엘릭서는, 아주 많은 프로세스를 사용할 수 있어서 좋다.
  - 프로세스마다, 다른 heap 영역을 가진다.
  - 가비지 컬렉션이 훨씬 빠르다.
  - 프로    세스가 종료되면 모든 데이터가 사라지므로, 가비지 컬렉션이 필요한 상황자체도 적다!
  
- capitalize 연산
  - 문자열을 직접 갱신하지 않음
  - 연산을 적용한, 복사본을 반환받는다 ( 새로운 메모리 )

``` elixir
name = "elixir"
cap_name = String.capitalize name
name # "elixir" 출력됨 ( capitalize가 원본을 수정하지 않음!! )
```

# 기초 문법
- 자료형

## 내장 자료형
- 값 타입
  - 정수
  - 실수
  - 아톰
  - 범위
  - 정규식
- 시스템 타입
  - 프로세스ID, 포트
  - 레퍼런스(주소)
- 컬렉션 타입
  - 튜플
  - 리스트
  - 맵
  - 바이너리
- 함수
  
문자열이나, 구조체가 없다??
- 기본자료형의 조합으로 사용되어진다.

정규식과 범위가 값 타입에 속하는지?
- 엄밀히 말하면 구조체

### 값 타입
- 숫자, 이름, 범위, 정규식

#### 정수
  - 10진수, 16진수, 8진수, 2진수
  - 10진수 중간에는 (_)언더 스코어를 사용할 수 있다.
    - 주로 큰 숫자를 표현 ( 100_000_000 )
- 값의 크기에 제한이 없음
  - 0이 351235개 있는 수와 같이 엄청난 큰 숫자도 표현가능하다.
  
#### 실수
  - 부동소수점수, 소수점을 이용해 쓸 수 있다.
  - 소수점 좌우에는 적어도 한 자리 이상의 숫자가 있어야 한다.
  - 숫자뒤에 지수부를 붙일 수도 있다.
  - 1.0, 0.24545, 0.12342525235, 34234.0e-5
  - IEEE754 배정밀도를 따름
    - 10진수 기준, 16자리 내외의 가수부, 10^308 길이의 지수부를 가진다. ( 가수부.지수부 )

#### 아톰
- 값의 이름을 나타내는 상수
- 문자열 앞에 ":"을 사용
- 느낌표, 물음표로 끝날 수 있고, ""로 감쌀 수도 있다.
- :var@2, :<>, :===, :"func/2", :"long john silver", :테스트, :일본어가능
- 아톰의 값 == 아톰의 이름

#### 범위
- 연속된 정수 (start..end)
- 시작값과, 끝값은 정수여야 한다.

#### 정규식
- ~r{정규식}, ~r{정규식}옵션
- 중괄호 말고, 다양한 문자를 구분자로 사용할 수도 있다.
- 전통적인 ~r/.../ 도 사용가능하지만, 내부 "/" 문자를 이스케이프 해야하기 때문에 기피한다.

- f : firstline - 여러 줄로 이루어진 문자열 => 첫번째 줄에서 매칭 시작
- i : caseless - 대소문자 구별 x
- m : multiline - 문자열이 여러줄, ^$로 시작과 끝을 나타낸다.
- s : dotail - "."이 개행문자에도 매칭되도록 함
- U : ungreedy - * or + 등의 수식기호를 만족하는 모든 것들을 매칭하도록 한다.(기본은 1개만 매칭)
- u : unicode - \p 등의 유니코드용 패턴 사용
- x : extended - 공백문자, 주석 무시

### 시스템 타입
- 얼랭VM의 자원 표시

#### 프로세스ID , 포트
- 프로세스ID : 로컬, 리모트에 있는 프로세스
  - self() : 현재 PID 얻기
- 포트 : 프로그램이 데이터 Write/Read 할 자원

#### 레퍼런스
- make_ref 함수를 호출, 전역적으로 <b>고유한 레퍼런스</b>를 얻을 수 있다.
- 레퍼런스끼리는 값이 같을 수 없다.

### 컬렉션 타입
#### 튜플 
- {:ok, 42, "next"}
- 순서에 맞게, 여러 값을 모은 것
- 데이터 타입 상관 없음 
- 한번 만들면 수정불가

- 일반적인 Elixir의 함수
  - 성공시, 첫번째 값이 :ok인 튜플을 반환
  - 실패시, 첫번재 값이 :error인 튜플을 반환
    - :enoent - file not exists

#### 리스트
- 싱글 링크드 리스트
  - 첫번째 요소를 Head라고 부르고,
  - 나머지 요소를 Tail이라고 부르는 자료구조
  - 마지막과 가까운 위치를 검색하는 것은 비용이 크다.
- 순서없이, 여러 값을 모아 저장한것

``` elixir
[1,2,3] ++ [4,5]  # [1,2,3,4,5]
[1,2,3,4] -- [3,4]  # [1,2]
1 in [1,2,3,4]  # 포함 여부 검사하기 (true/false)
```
결과인 리스트는, 불변성의 법칙에 의해 항상 새로운 메모리를 사용한다.


#### 키워드 리스트
- key:value 쌍 구조로 만든,<b>리스트</b>
- 하나의 key를 여러번 사용할 수 있다.

``` elixir
[{:name, "Jinho"}, {:city, "Seoul"}, {:likes, "Programming"}]  # 기본형
[name: "Jinho", city: "Seoul", likes: "Programming"]  # 축약형

DB.save(record, [{:usr_transaction, true}, {:logging, "HIGH"}]) # 기본형 
DB.save(record, usr_transaction: true, logging, "HIGH") # 마지막인자가 키워드 리스트이므로, 대괄호 생략
```
- 함수를 호출할 때 키워드 리스트가 마지막 인자라면, 대괄호 생략 가능
  
#### Map 
- key:value 쌍 구조로 만든,<b>컬렉션</b>
- 하나의 key를, 단 1번만 사용가능하다.
- key에 어떤 타입이든 들어갈 수 있다.
- 일반적으로, key의 타입을 통일하는 편이다.
- 패턴 매칭을 할수 있다.
- 크기가 클수록 효율적

``` elixir
map = %{key => value, key => value}  # map 만들기

map[key]  # map 읽기 (접근), 없으면 nil 반환


response_types = %{{:error, :enoent} => :fatal, {:error, :busy} => :retry}

response_types[{:error, :enoent}]  # map 읽기 ( key값이 튜플 )


colors = %{red: 0xff0000, green, 0x00ff00, blue: 0x0000ff}

colors.red  # map 읽기 ( key값이 아톰인 경우에만 "." 사용가능 )
```


#### 바이너리
- 연속된 비트로 만든 데이터 R/W
  - JPEG or MP3 ...
- <<, >> 로 바이너리 정보 표현

``` elixir
bin = <<1, 2>>  # 바이너리 정보 바인딩

byte_size(bin)  # 2 출력


# 1byte를, 1bit 단위로 쪼개서 바인딩
bin = <<3 :: size(2), 5 :: size(4), 1 :: size(2)>>
# 11 + 0101 + 01 => 0b11010101 = 128 + 64 + 16 + 4 + 1 = 213
```


#### 날짜와 시간

Calendar module 사용

- Date
  - 년, 월, 일, 사용하는 캘린더 주소
  
``` elixir
d1 = Date.new(2023,03,30)
# {:ok, ~D[2023-03-30]}  # ~D[] : 시길, 엘릭서 자료구조 만들기

d2 = ~D[2022-03-30]
# d1 == d2 : true

Date.day_of_week(d1)
d3 = Date.add(d2, 7)
first_half = Date.range(d1, d3)
# DataRange<~D[2023-03-30], ~D[2023-03-30]>

Enum.count(first_half) # 일 수 세기 가능
```

- Time
  - 시, 분, 초 사용하는 캘린더 주소
  
``` elixir
{:ok, t1} = Time.new(12,34,56)
# {:ok, ~T[12:34:56]}

t2 = ~T[12:34:56]
# t1 == t2  : true

# 초단위로 더하기
Time.add(t1, 3600)  # ~T[13:34:56]

# 옵션 주기
Time.add(t1, 3600, :millisecond)  # ~T[12:34:59:600]

```


- NaiveDateTime  ( 날짜 시간 전부 담는 자료형 )
  - ~N[...]
- Datetime  ( 타임존 정보 포함 )
#### 규칙 (코드 컨벤션)
- 변수 이름
 - 기존과 특수한 기호들을 이름으로 사용할 수 있다.
 - 연산자는 불가능하다.
 
- Module, Record, Protocol, behavior
  - 카멜케이스를 사용한다.
  
- 소스코드
  - 들여쓰기를 할때는, 탭 대신 공백을 두번 사용한다.
  
- 주석
  - # 으로 한줄 주석

- 참거짓
  - true, false, nil (논리연산 거짓)
  - 세값은 모두 아톰이다. (:true, :false, :nil)
  - 세값 의외의 모든 값은, 전부다 true 취급된다.
  
- 비교 연산자
  ( 엘릭서는 모든 형식끼리 비교가능 / 이를 이용해서, 같은 형식끼리 분류 가능 )
  - a === b
  - a !== b

  - a == b
  - a != b
  
  - a > b
  - a >= b
  - a < b
  - a <= b
  
- 논리 연산
  ( 조건은 엄격하게, 결과는 유연하게 )
  ( 논리 연산 - 첫번째 인자로, true false를 받아야함 )
  - a or b  # a가 참이면 true, 아니면 b 
  - a and b  # a가 거짓이면 false, 아니면 b 
  - not a  # true/false
  
  ( 유연한 논리 연산 - 인자 제한 없음 )
  - a || b  # a가 참으로 취급되면 a, 아니면 b
  - a && b  # a가 참으로 취급되면 b, 아니면 a
  - !a  # a가 참으로 취급되면 false, 아니면 true
  
 
 - 산술 연산
   - * - * / div rem
   - div(a,b) : 정수연산
   - rem(a,b) : 나머지 연산
   
- 연결 연산
  - binary1 <> binary2  # 두 바이너리 합치기
  - list1 ++ list2  # 두 리스트 합치기
  - list1 -- list2  # list1의 복사본에서, list2 값들 제거하기

- in 연산
  - a in enum  # a가 enum( 리스트, 범위, 맵 등의 컬렉션 )에 포함되는지

#### 변수 스코프
- 변수는 일정 범위를 가진다 (스코프)
  - 기본적으로, 함수 body 부분을 범위로 가진다.
  - 함수 외부로 벗어나면, 사라진다.
- module은 로컬 변수에 대한 범위를 정한다.
  - module 내부의 변수들은, 같은 module에 있는 함수에서는 접근 불가능. (상위에서만 접근가능)
  
여러 언어들은 {} 중괄호를 사용하여 범위(스코프) 를 나누지만,
Elixir에서는 do를 사용한다.

``` elixir
int line_no = 50;

if(line_no == 50) do
  IO.puts "new-page\f"
  line_no = 0
end

IO.puts line_no
```

line_no를 초기화 하지 않았다면?
- 블록외부에서 line_no를 사용할 수 없다.

- with 표현식
  - 변수의 로컬 스코프 정함
    - 연산하기 위한 임시변수를, 일정 범위에서만 사용하고 싶을때
    - 패턴 매칭이 실패했을 경우, 대처하고 싶을때

##### 유연한 패턴매칭
``` elixir
# a와 1째 요소를 바인딩하고, 그결과를 do스코프 내부에 전달한다. => 1
with [a|_] <- [1,2,3], do: a
``` 

## 익명함수
- "->" 기호를 기준으로, 왼쪽이 인자 & 오른쪽이 몸체다
- 익명함수는 "."을 이용하여 호출한다
  - 기명함수 호출과 구별하기 위해서
- 변수와 함수는, 서로 다른 네임스페이스를 사용한다. (소속이 다르다)
  - 변수 네임스페이스에서 함수 찾기 ( 익명함수 )
  - 함수 네임스페이스에서 함수 찾기 ( 기명함수 )
    - 인자가 없는경우, 괄호를 생략가능하다.
### 함수 호출과정과 패턴매칭
- 전달하는 인자와, 함수의 매개변수를 패턴매칭하는 방식으로 호출된다
     
