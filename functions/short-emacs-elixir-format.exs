# 익명함수는 이름이 없다. ( 바인딩 해서 사용할 수 있기는 함 )
# fn n -> n + 1 end
# & : 뒤에 나오는 모든 것을 함수로 바꾸기 ( 함수캡쳐연산자 )
# &1 : 1th argument
add_one = &(&1 + 1)

add_one.(45)
# => 46

speak = &IO.puts(&1)

# 이 경우, Elixir가 speak 익명함수를, IO.puts() 기명함수의 주소를 가지도록함 (최적화)
# 최적화하려면, 인자가 같은 순서로 들어가야 한다.

# 해당 문장은 최적화가 되지만, (기명함수의 주소값 가짐)
rnd = &Float.round(&1, &2)
# 아래 문장은 최적화 되지 않고, 새로운 함수를 만들게 된다.
rnd = &Float.round(&2, &1)

# &{...}, &[...] : function
# &기호 내부에 들어있는 모든 함수들이 실행되고, 반환값으로 바뀐다.
# 나누기 값과, 나머지 값을 튜플 형식으로 출력하는 함수 만들기
divrem = &{div(&1, &2), rem(&1, &2)}
divrem.(13, 5)
# => {2, 3}

# 문자열 반환하는 함수 만들기 
s = &"bacon and #{&1}"
s.("custard")
# => "bacon and custard"

# 정규식 반환하는 함수 만들기 
match_end = &~r/.*#{&1}$/ 
"cat" =~ match_end.("t")
# => true

&(match_end,1)

# 간단하게 기명함수를 호출하는 익명함수 만들기
# &기명함수/인자갯수
p = &IO.puts/1
# 익명함수로 사용할 수 있다!
p.("Hello World")

# 검사, 새로운 값 반환
IO.inspect(3)
